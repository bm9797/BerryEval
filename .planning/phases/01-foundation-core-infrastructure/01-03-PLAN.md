---
phase: 01-foundation-core-infrastructure
plan: 03
type: execute
wave: 3
depends_on:
  - 02
files_modified:
  - .github/workflows/ci.yml
  - berryeval/metrics/_native.py
autonomous: true
requirements:
  - PROJ-04
  - NATV-07
must_haves:
  truths:
    - "CI pipeline runs lint (Ruff), type check (mypy), and test (pytest) on every push and PR"
    - "CI tests pass on Linux, macOS, and Windows"
    - "CI tests pass on Python 3.10, 3.11, and 3.12"
    - "When C extension is unavailable, system falls back to pure Python without error"
    - "BACKEND variable reports 'python' when no C extension is installed"
  artifacts:
    - path: ".github/workflows/ci.yml"
      provides: "GitHub Actions CI pipeline with matrix strategy"
      contains: "matrix"
      min_lines: 30
    - path: "berryeval/metrics/_native.py"
      provides: "C extension wrapper with graceful fallback"
      contains: "ImportError"
  key_links:
    - from: ".github/workflows/ci.yml"
      to: "pyproject.toml"
      via: "pip install -e '.[dev]'"
      pattern: "pip install"
    - from: ".github/workflows/ci.yml"
      to: "tests/"
      via: "pytest execution"
      pattern: "pytest"
    - from: "berryeval/metrics/__init__.py"
      to: "berryeval/metrics/_native.py"
      via: "try/except ImportError fallback"
      pattern: "except ImportError"
---

<objective>
Create the GitHub Actions CI pipeline and finalize the Python/C fallback mechanism so the project is CI-ready and gracefully handles missing C extensions.

Purpose: Ensure every code change is validated across 3 operating systems and 3 Python versions automatically. Establish the fallback pattern that Phase 5 will build upon.
Output: Working CI configuration and robust backend dispatch with logging.
</objective>

<execution_context>
@/Users/benjaminmarks/.claude/get-shit-done/workflows/execute-plan.md
@/Users/benjaminmarks/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-core-infrastructure/01-RESEARCH.md
@.planning/phases/01-foundation-core-infrastructure/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GitHub Actions CI pipeline</name>
  <files>
    .github/workflows/ci.yml
  </files>
  <action>
    Create `.github/workflows/ci.yml` with three jobs:

    **Job 1: lint** (ubuntu-latest, Python 3.12 only)
    - Checkout code
    - Setup Python with pip cache
    - pip install -e ".[dev]"
    - ruff check .
    - ruff format --check .

    **Job 2: typecheck** (ubuntu-latest, Python 3.12 only)
    - Checkout code
    - Setup Python with pip cache
    - pip install -e ".[dev]"
    - mypy berryeval

    **Job 3: test** (matrix strategy)
    - os: [ubuntu-latest, macos-latest, windows-latest]
    - python-version: ["3.10", "3.11", "3.12"]
    - fail-fast: false (run all combinations even if one fails)
    - Checkout code
    - Setup Python with pip cache (use actions/setup-python@v5 with cache: 'pip')
    - pip install -e ".[dev]"
    - pytest --cov=berryeval --cov-report=xml -v

    **Triggers:**
    - push to main branch
    - pull_request to main branch

    **Important details:**
    - Use actions/checkout@v4 and actions/setup-python@v5
    - Python "3.10" must be quoted (YAML interprets 3.10 as float 3.1)
    - Use `cache: 'pip'` in setup-python for automatic pip caching
    - No C extension build steps (that's Phase 5)
  </action>
  <verify>
    ```bash
    # Validate YAML syntax
    python -c "import yaml; yaml.safe_load(open('.github/workflows/ci.yml'))"

    # Verify key elements present
    grep -q "matrix" .github/workflows/ci.yml
    grep -q "ubuntu-latest" .github/workflows/ci.yml
    grep -q "macos-latest" .github/workflows/ci.yml
    grep -q "windows-latest" .github/workflows/ci.yml
    grep -q '"3.10"' .github/workflows/ci.yml
    grep -q '"3.11"' .github/workflows/ci.yml
    grep -q '"3.12"' .github/workflows/ci.yml
    grep -q "ruff check" .github/workflows/ci.yml
    grep -q "mypy" .github/workflows/ci.yml
    grep -q "pytest" .github/workflows/ci.yml
    echo "CI config validated"
    ```
  </verify>
  <done>
    - .github/workflows/ci.yml exists with valid YAML
    - Three jobs defined: lint, typecheck, test
    - Matrix covers 3 OS x 3 Python versions = 9 test combinations
    - All required tools (ruff, mypy, pytest) are invoked
    - pip caching configured for faster CI runs
  </done>
</task>

<task type="auto">
  <name>Task 2: Finalize C extension fallback mechanism with logging</name>
  <files>
    berryeval/metrics/_native.py
    berryeval/metrics/__init__.py
  </files>
  <action>
    **berryeval/metrics/_native.py** — Create the C extension wrapper module:
    - Document that this module wraps the optional C acceleration layer
    - Attempt to import from the C extension module (e.g., `berryeval._berryeval_native`)
    - If ImportError: this is expected in Phase 1, define stub functions that raise ImportError
    - The module should be importable but its functions should raise ImportError when called if no C extension exists
    - Actually, simpler approach: just let the import fail. The __init__.py handles the try/except.

    Simplest correct approach for _native.py:
    ```python
    """C extension wrapper for accelerated metric computation.

    This module attempts to import the compiled C extension.
    If unavailable, berryeval/metrics/__init__.py falls back to pure Python.

    The C extension will be implemented in Phase 5.
    """
    # Phase 5 will replace this with actual C bindings
    raise ImportError("C extension not available — using pure Python fallback")
    ```

    **berryeval/metrics/__init__.py** — Update the dispatch to include logging:
    - Use Python's logging module (import logging, logger = logging.getLogger(__name__))
    - On successful C import: logger.debug("Using native C backend for metrics")
    - On ImportError fallback: logger.debug("C extension not available, using pure Python backend")
    - Ensure BACKEND is set to "python" or "native" correctly
    - Public API: recall_at_k, precision_at_k, mrr, ndcg, hit_rate
    - Each public function: validate_inputs() then call _implementation()
    - Also export get_backend() -> str for programmatic checking

    Verify the fallback works:
    ```python
    from berryeval.metrics import BACKEND, get_backend
    assert BACKEND == "python"
    assert get_backend() == "python"
    ```
  </action>
  <verify>
    ```bash
    # Verify fallback works silently
    python -c "from berryeval.metrics import BACKEND; assert BACKEND == 'python'; print(f'Backend: {BACKEND}')"
    python -c "from berryeval.metrics import get_backend; assert get_backend() == 'python'; print('Fallback OK')"

    # Verify all metrics still work after changes
    pytest tests/metrics/ -v

    # Verify no ruff/mypy regressions
    ruff check berryeval/metrics/
    mypy berryeval/metrics/
    ```
  </verify>
  <done>
    - _native.py raises ImportError (expected in Phase 1)
    - __init__.py catches ImportError and falls back to _python
    - BACKEND == "python" when no C extension
    - get_backend() returns "python"
    - Fallback logged at DEBUG level (not warning/error)
    - All existing metric tests still pass
    - ruff and mypy pass
  </done>
</task>

</tasks>

<verification>
```bash
# Full project validation
pip install -e ".[dev]"
ruff check .
ruff format --check .
mypy berryeval
pytest tests/ -v --cov=berryeval --cov-report=term-missing

# CI config validation
python -c "import yaml; yaml.safe_load(open('.github/workflows/ci.yml')); print('CI YAML valid')"

# Fallback verification
python -c "
from berryeval.metrics import BACKEND, recall_at_k, precision_at_k, mrr, ndcg, hit_rate
import numpy as np

print(f'Backend: {BACKEND}')
assert BACKEND == 'python'

# Quick smoke test all metrics
r = np.array([[1,2,3,4,5]], dtype=np.int32)
v = np.array([[1,3,5,-1,-1]], dtype=np.int32)
print(f'recall@5: {recall_at_k(r, v, 5)}')
print(f'precision@5: {precision_at_k(r, v, 5)}')
print(f'mrr@5: {mrr(r, v, 5)}')
print(f'ndcg@5: {ndcg(r, v, 5)}')
print(f'hit_rate@5: {hit_rate(r, v, 5)}')
print('All metrics working with Python fallback')
"
```
</verification>

<success_criteria>
- CI pipeline configured with lint + typecheck + test jobs
- Matrix strategy covers Linux/macOS/Windows x Python 3.10/3.11/3.12
- C extension fallback is graceful (no errors, just debug log)
- BACKEND correctly reports "python"
- All existing tests continue to pass
- Full project passes ruff, mypy, pytest
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-core-infrastructure/01-03-SUMMARY.md`
</output>
